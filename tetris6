#include "block.h"
#include <Windows.h>
#include <stdio.h>
#include <stdlib.h> 
#include <time.h>
#include <conio.h>

#define WIDTH  12 * 2 // 네모 블럭이 x좌표 2칸을 차지하는 관계로 가로줄에 2를 곱해 보정
#define HEIGHT 17 // 높이

int stageInfo[HEIGHT + 2][WIDTH / 2 + 1] = { 0 }; // 현재 스테이지 정보를 0, 1, 2로 저장하는 배열

int gameover = 1;//0이 되면 게임 종료

int gamePoint = 0;//포인트 저장 변수

void eraseBlock(HANDLE hConsole, int block, int x, int y) {
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			if (blockModel[block][i][j] == 1) {
				COORD pos = { (x + j) * 2, y + i };
				SetConsoleCursorPosition(hConsole, pos);
				printf("  ");
			}
		}
	}
}

void drawBlock(HANDLE hConsole, int block, int x, int y) {
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			if (blockModel[block][i][j] == 1) {
				COORD pos = { (x + j) * 2, y + i };
				SetConsoleCursorPosition(hConsole, pos);
				printf("■");
			}
		}
	}
}

void redrawStage(HANDLE hConsole) {
	for (int i = 0; i <= HEIGHT; i++) {
		for (int j = 1; j < WIDTH / 2; j++) {
			COORD pos = { j * 2, i };
			SetConsoleCursorPosition(hConsole, pos);
			if (stageInfo[i][j] == 0) {
				printf("  ");
			}
			else if (stageInfo[i][j] == 2) {
				printf("■");
			}
		}
	}
}

void pointPrint(HANDLE hConsole) {
	COORD p;
	p.X = WIDTH + 4;
	p.Y = HEIGHT / 2;
	SetConsoleCursorPosition(hConsole, p);
	printf("점수: %d점", gamePoint);
}


//r=0은 왼쪽 r=1은 오른쪽 r=2는 회전
int detectCollision(int x, int y, int block, int originblock, int r) {
	int canMove = 1;

	if (r == 2) {
		int b = block + 1;
		if (b >= originblock + 4) {
			b = originblock;
		}
		for (int i = 0; i < 4; i++) {
			for (int j = 0; j < 4; j++) {
				if (blockModel[b][i][j] == 1) {
					//화면 x값: (x + j) * 2;
					//y값 = y + i;
					if (stageInfo[y + i][x + j] > 0) {
						canMove = 0;
					}

				}
			}
		}
	}

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			if (blockModel[block][i][j] == 1) {
				//화면 x값: (x + j) * 2;
				//y값 = y + i;
				if (r==0) {
					if (stageInfo[y + i][x + j - 1] > 0) {
						canMove = 0;
					}
				}
				else if (r == 1) {
					if (stageInfo[y + i][x + j + 1] > 0) {
						canMove = 0;
					}
				}
				
			}
		}
	}

	if (canMove) {
		return 1;
	}
	else {
		return 0;
	}
}


void blockSpawn() {
	HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	srand(time(NULL));
	int block = (rand() % 7) * 4;
	int originblock = block;
	int x = WIDTH / 4;
	int y = 0;
	int stop = 1;

	while (stop) {
		int time = 0;
		int key = 0;
		drawBlock(hConsole, block, x, y);
		while (time < 1000) {
			if (_kbhit()) {
				key = _getch();
				if (key == 224) {
					key = _getch();
					if (key == 75) { // 왼쪽
						eraseBlock(hConsole, block, x, y);

						if (detectCollision(x, y, block, originblock, 0)) {
							x--;
						}
						drawBlock(hConsole, block, x, y);
					}

					if (key == 77) { // 오른쪽
						eraseBlock(hConsole, block, x, y);
						if (detectCollision(x, y, block, originblock, 1)) {
							x++;
						}
						drawBlock(hConsole, block, x, y);
					}


					if (key == 72) { // 위
						eraseBlock(hConsole, block, x, y);
						if (detectCollision(x, y, block, originblock,2)) {
							block++;
							if (block >= originblock + 4) {
								block = originblock;
							}
						}
						drawBlock(hConsole, block, x, y);
					}

					if (key == 80) { // 아래
						break;
					}
				}
				if (key == 32) { // 스페이스바 = 하드드롭
					eraseBlock(hConsole, block, x, y);

					while (1) {
						int canFall = 1;
						for (int i = 0; i < 4; i++) {
							for (int j = 0; j < 4; j++) {
								if (blockModel[block][i][j] == 1) {
									if (stageInfo[y + i + 1][x + j] > 0) {
										canFall = 0;
									}
								}
							}
						}
						if (canFall) {
							y++; // 더 내려감
						}
						else {
							break; // 더 이상 못 내려가면 멈춤
						}
					}

					drawBlock(hConsole, block, x, y);
					stop = 0; // 즉시 블록 고정
					break;
				}
			}
			Sleep(10);
			time += 10;
		}

		for (int i = 0; i < 4; i++) {
			for (int j = 0; j < 4; j++) {
				if (blockModel[block][i][j] == 1) {
					if (stageInfo[y + i + 1][x + j] > 0) {
						eraseBlock(hConsole, block, x, y);
						stop = 0;
					}
				}
			}
		}

		if (stop == 1) {
			eraseBlock(hConsole, block, x, y);
			y++;
		}
		else {
			eraseBlock(hConsole, block, x, y);
		}
	}

	//마무리
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			if (blockModel[block][i][j] == 1) {
				if (y + i <= 1) {
					gameover = 0;
				}
				stageInfo[y + i][x + j] = 2;
			
			}
		}
	}
	drawBlock(hConsole, block, x, y);
}
void delLine() {
	int linesCleared = 0;

	for (int y = HEIGHT; y > 0; y--) {
		int del = 1;
		for (int x = 1; x < WIDTH / 2; x++) {
			if (stageInfo[y][x] != 2) {
				del = 0;
				break;
			}
		}

		if (del) {
			linesCleared++;
			// 한 줄 내리기
			for (int i = y; i > 0; i--) {
				for (int j = 1; j < WIDTH / 2; j++) {
					stageInfo[i][j] = stageInfo[i - 1][j];
				}
			}
			// 맨 윗줄 초기화
			for (int j = 1; j < WIDTH / 2; j++) {
				stageInfo[0][j] = 0;
			}

			y++; // 같은 줄 다시 검사
		}
	}

	// 점수 계산
	if (linesCleared > 0) {
		switch (linesCleared) {
		case 1: gamePoint += 100; break;
		case 2: gamePoint += 300; break;
		case 3: gamePoint += 500; break;
		case 4: gamePoint += 800; break;
		}
	}

	redrawStage(GetStdHandle(STD_OUTPUT_HANDLE));
	pointPrint(GetStdHandle(STD_OUTPUT_HANDLE));
}



int main() {
	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE);

	CONSOLE_CURSOR_INFO curCursorInfo;
	GetConsoleCursorInfo(hConsoleOut, &curCursorInfo);
	curCursorInfo.bVisible = 0;
	SetConsoleCursorInfo(hConsoleOut, &curCursorInfo);

	//바닥
	for (int i = 0; i < WIDTH; i++) {
		COORD pos1 = { i, HEIGHT + 1 };
		stageInfo[HEIGHT + 1][i / 2] = 1;
		SetConsoleCursorPosition(hConsoleOut, pos1);
		printf("─");
	}

	//왼쪽벽
	for (int i = 0; i <= HEIGHT; i++) {
		COORD pos1 = { 0, i };
		stageInfo[i][0] = 1;
		SetConsoleCursorPosition(hConsoleOut, pos1);
		printf("│");

	}
	COORD p = { 0, HEIGHT + 1 };
	stageInfo[HEIGHT + 1][0] = 1;
	SetConsoleCursorPosition(hConsoleOut, p);
	printf("└");

	//오른쪽벽
	for (int i = 0; i <= HEIGHT; i++) {
		COORD pos1 = { WIDTH, i };
		stageInfo[i][WIDTH / 2] = 1;
		SetConsoleCursorPosition(hConsoleOut, pos1);
		printf("│");

	}
	p.X = WIDTH;
	p.Y = HEIGHT + 1;
	stageInfo[HEIGHT + 1][WIDTH / 2] = 1;
	SetConsoleCursorPosition(hConsoleOut, p);
	printf("┘");

	pointPrint(hConsoleOut);

	gamePoint = 0;

	while (gameover) {
		blockSpawn();
		delLine();
	}

	for (int i = 0; i <= HEIGHT; i++) {
		for (int j = 0; j <= WIDTH / 2; j++) {
			stageInfo[i][j] = 0;
		}
		redrawStage(GetStdHandle(STD_OUTPUT_HANDLE));
		Sleep(200);
	}
	p.X = WIDTH / 2 - 4;
	p.Y = HEIGHT / 2;
	SetConsoleCursorPosition(hConsoleOut, p);
	printf("GAME OVER!");

	p.Y = HEIGHT + 5;
	SetConsoleCursorPosition(hConsoleOut, p);
	return 0;
}
